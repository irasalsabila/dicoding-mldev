# -*- coding: utf-8 -*-
"""submission_predictive_analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZCSpz2jtGq67B0rIZ0kdMMLnR6logzlr

# Heart Failure Predictive Analysis

Domain yang dipilih untuk dilakukan prediksi adalah domain kesehatan, yang berfokus pada penyakit kardiovaskular. 

Penyakit kardiovaskular (CVD) adalah penyebab utama kematian di seluruh dunia, merenggut sekitar 17,9 juta jiwa setiap tahun dan menyumbang 31% dari semua kematian di seluruh dunia. Empat dari setiap lima kematian akibat penyakit kardiovaskular disebabkan oleh serangan jantung dan stroke, dan sepertiga dari kematian ini terjadi lebih awal pada orang di bawah usia 70 tahun. Gagal jantung adalah kejadian umum yang disebabkan oleh CVD dan dataset ini berisi 11 fitur yang dapat digunakan untuk memprediksi kemungkinan penyakit jantung. 
 
Orang dengan penyakit kardiovaskular atau risiko kardiovaskular tinggi (karena adanya satu atau lebih faktor risiko seperti hipertensi, diabetes, hiperlipidemia, kondisi medis yang sudah ada sebelumnya) adalah pengguna awal yang memerlukan deteksi dan manajemen dini, di mana model _machine learning_ yang dibuat dapat sangat membantu. 

Referensi:
[1] [Heart Failure: Diagnosis, Severity Estimation and Prediction of Adverse Events Through Machine Learning Techniques](https://www.sciencedirect.com/science/article/pii/S2001037016300460)

## Business Understanding

Pada bagian _Business Understanding_ akan dijelaskan mengenai permasalahan yang akan diselesaikan (_problem statements_), tujuan (_goal_), dan solusi yang diajukan (_solution statements_).

### Problem Statements
Bagaimana mengetahui pasien memiliki penyakit jantung (_heart disease_) berdasarkan riwayat dari variabel-variabel kesehatan yang ada?

### Goals
Untuk menyelesaikan permasalahan yang telah disampaikan pada bagian _Problem Statement_, maka dibuat model yang digunakan untuk memprediksi apakah seseorang memiliki penyakit jantung (_heart disease_) berdasarkan riwayat kesehatannya.

### Solution statements
Solusi pembuatan model yang dilakukan adalah dengan menerapkan 3 algoritma machine learning, terbatas pada **_K-NN_**, **_Random Forest_**, dan **_AdaBoost_**. Diterapkannya 3 algoritma tersebut bertujuan untuk mengkomparasi dan mendapatkan model atau algoritma yang memiliki tingkat _error_ yang paling kecil, sehingga prediksi penyakit jantung memiliki akurasi yang tinggi.

- **_K-NN_**
Algoritma _K-Nearest Neighbor_ (K-NN) adalah algoritma _machine learning_ yang sederhana dan mudah diterapkan, yang mana umumnya digunakan untuk menyelesaikan masalah klasifikasi dan regresi. Algoritma ini termasuk dalam _supervised learning_. Tujuan dari algortima K-NN adalah untuk mengidentifikasi _nearest neighbor_ dari titik yang diberikan, sehingga dapat menetapkan label prediksi ke titik tersebut.

- **_Random Forest_**
_Random forest_ adalah kombinasi dari masing â€“ masing _tree_ atau pohon, yang kemudian dikombinasikan ke dalam satu model. _Random Forest_ bergantung pada sebuah nilai vector acak dengan distribusi yang sama pada semua pohon yang masing masing _tree_ memiliki kedalaman yang maksimal.

- **_AdaBoost_**
_AdaBoost_ atau _Adaptive Boost_ merupakan algoritma yang memanfaatkan _bagging_ dan _boosting_ untuk meningkatkan akurasi. Sama seperti algoritma _random forest_, algoritma _AdaBoost_ juga menggunakan beberapa _decision tree_ untuk melakukan prediksi.
"""

# Commented out IPython magic to ensure Python compatibility.
# libraries

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import seaborn as sns

"""## Data Understanding
Dataset yang digunakan pada proyek _machine learning_ merupakan **918 data observasi** yang didapat dari situs [kaggle](https://www.kaggle.com/datasets/fedesoriano/heart-failure-prediction) dan [UCI Machine Learning Repository] (http://archive.ics.uci.edu/ml/datasets/Heart+Disease). Terdapat 11 fitur yang dapat digunakan untuk memprediksi kemungkinan penyakit jantung. 

**Variabel-variabel pada Heart Failure UCI Dataset adalah sebagai berikut:**

1.  Age: usia pasien, dalam tahun (_years_)
2.  Sex: jenis kelamin pasien 
	- M: Pria (_Male_), 
	- F: Wanita (_Female_)
3.  ChestPainType: tipe sakit pada dada
    - TA: Typical Angina, 
    - ATA: Atypical Angina, 
    - NAP: Non-Anginal Pain, 
    - ASY: Asymptomatic
4.  RestingBP: tekanan darah (_mm Hg_)
5.  Cholesterol: serum cholesterol (_mm/dl_)
6.  FastingBS: gula darah 
    - if FastingBS > 120 mg/dl 
    - 0: sebaliknya (_otherwise_)
7.  RestingECG: hasil ECG 
    - Normal: Normal, 
    - ST: memiliki kelainan gelombang ST-T (inversi gelombang T dan/atau elevasi atau depresi ST > 0,05 mV), 
    - LVH: menunjukkan kemungkinan atau pasti hipertrofi ventrikel kiri menurut kriteria Estes
8.  MaxHR: detak jantung maksimum tercapai (Nilai numerik antara 60 dan 202)
9.  ExerciseAngina: angina yang diinduksi oleh olahraga [
    - Y: Ya, 
    - N: Tidak (_No_)
10.  Oldpeak: oldpeak = ST (Nilai numerik diukur dalam depresi)
11.  ST_Slope: kemiringan puncak latihan segmen ST 
     - Up: upsloping, 
     - Flat: flat, 
     - Down: downsloping]
12.  HeartDisease: kelas keluaran
     - 1: Penyakit Jantung (_heart disease_), 
     - 0: Normal

[2]: [Heart Failure UCI Dataset](http://archive.ics.uci.edu/ml/datasets/Heart+Disease)
"""

# load the dataset
heart_disease = pd.read_csv('heart.csv') # load to read dataset file
heart_disease # display dataset

"""Explanatory Data Analysis"""

# getting information of dataset
heart_disease.info()

"""Dari informasi yang didapatkan, disimpulkan terdapat 11 fitur pada data _heart disease_, yang mana memiliki 5 fitur _categorical_ dan 7 fitur _numerical_.

_Categorical_ fitur di antaranya adalah `Sex`, `ChestPainType`, `RestingECG`, `ExerciseAngina`, dan `ST_Slop`.

_Numerical_ fitur di antaranya adalah `Age`, `RestingBP`, `Cholesterol`, `FastingBS`, `MaxHR`, `Oldpeak`, dan `HeartDisease`.

`describe()` adalah _command_ yang digunakan untuk mengetahui deskripsi statistik dari dataset _heart disease_.
"""

# getting description of heart_disease dataset
heart_disease.describe()

"""### Univariate Analysis"""

heart_disease.columns

"""Perlu membagi dataset menjadi 2 fitur, yakni categorical dan numerical"""

# assign numerical and categorical
categorical_feature = ['Sex', 'ChestPainType', 'FastingBS', 'RestingECG', 'ExerciseAngina', 'ST_Slope', 'HeartDisease']
numerical_feature = ['Age', 'RestingBP', 'Cholesterol', 'MaxHR', 'Oldpeak']

print('fitur categorical: ', categorical_feature)
print('fitur numerical: ', numerical_feature)

"""#### Analisis terhadap fitur categorical

Perlu diketahui bahwa variabel `target` dari _predictive analysis_ yang dilakukan adalah `HeartDisease`.

Dari _plot_ yang dibuat, dapat diketahui bahwa data lebih banyak menunjukkan kondisi _heart disease_ [1] dibanding kondisi normal [0].
"""

hd_label = ['Heart Disease', 'Normal']
hd_color = ["#8be04e", "#ebdc78"]

# checking plot of hd
plt.figure(figsize = (12, 5))
plt.subplot(1, 2, 1)
hd_plot = sns.countplot(x = heart_disease.HeartDisease, order = heart_disease.HeartDisease.value_counts().index, palette = hd_color)
hd_plot.set_title('Distribusi dari Heart Disease')
hd_plot.set_xticklabels(hd_label, fontsize = 15)
for p in hd_plot.patches:
   hd_plot.annotate('{:.0f}'.format(p.get_height()), (p.get_x()+0.25, p.get_height()+0.01))

plt.subplot(1, 2, 2)
hd_pie = heart_disease['HeartDisease'].value_counts()
hd_pie = hd_pie.plot.pie(explode = [0.2, 0.2], labels = hd_label, autopct = '%1.1f%%', shadow = True, colors = hd_color)
hd_pie.set_title(label = 'Persentase Heart Disease')
plt.axis('off')

"""Dari _plot_ yang dibuat, dapat diketahui bahwa distribusi jenis kelamin yang lebih banyak menunjukkan kondisi _heart disease_ adalah Pria, dibandingkan Wanita. Hal ini disebabkan karena data Pria lebih banyak dibanding Wanita.

Dari _pie plot_ yang dibuat, ditunjukkan bahwa Wanita memiliki penyakit jantung 3x lebih rendah dibandingkan Pria.
"""

sex_label = ['Pria', 'Wanita']
sex_color = ['pink', 'maroon']

# checking plot of sex
plt.figure(figsize = (12, 5))
plt.subplot(1, 2, 1)
sex_plot = sns.countplot(x = heart_disease.Sex, palette = sex_color)
sex_plot.set_title('Distribusi dari Jenis Kelamin')
sex_plot.set_xticklabels(sex_label, fontsize = 15)
for p in sex_plot.patches:
   sex_plot.annotate('{:.0f}'.format(p.get_height()), (p.get_x()+0.25, p.get_height()+0.01))

plt.subplot(1, 2, 2)
sex_pie = heart_disease['Sex'].value_counts()
sex_pie = sex_pie.plot.pie(explode = [0.2, 0.2], labels = sex_label, autopct = '%1.1f%%', shadow = True, colors = sex_color)
sex_pie.set_title(label = 'Persentase Jenis Kelamin')
plt.axis('off')

"""Dapat dilihat dari _bar plot_ dan _pie plot_ bahwa tipe sakit dada atau `ChestPainType` yang banyak ditemukan atau memiliki keluhan diderita paling tinggi adalah `ASY` atau _Asymptomatic_ sebesar 54%."""

chestpain_label = ['ASY', 'ATA', 'NAP', 'TA']
chestpain_colors = ["#50e991", "#e6d800", "#9b19f5", "#ffa300"]

# checking plot of sex
plt.figure(figsize = (12, 5))
plt.subplot(1, 2, 1)
chestpain_plot = sns.countplot(x = heart_disease.ChestPainType, order = heart_disease.ChestPainType.value_counts().index, palette = chestpain_colors)
chestpain_plot.set_title('Distribusi dari Tipe Sakit Dada')
chestpain_plot.set_xticklabels(chestpain_label, fontsize = 15)
for p in chestpain_plot.patches:
   chestpain_plot.annotate('{:.0f}'.format(p.get_height()), (p.get_x()+0.25, p.get_height()+0.01))

plt.subplot(1, 2, 2)
chestpain_pie = heart_disease['ChestPainType'].value_counts()
chestpain_pie = chestpain_pie.plot.pie(explode = [0.1, 0.1, 0.1, 0.1], colors = chestpain_colors, autopct = '%1.1f%%', shadow = True)
chestpain_pie.set_title(label = 'Persentase Tipe Sakit Dada')
plt.legend()
plt.axis('off')

"""Pada variabel `RestingECG` terdapat 3 level tekanan darah, yakni Normal, LVH, dan ST. Dari dua _plot_ yang menyajikan ketiga level tersebut, dapat diketahui bahwa kategori Normal memiliki mayoritas distribusi, yakni sebesar 63.8%."""

ecg_label = ['Normal', 'ST', 'LVH']
ecg_colors = ["#ede15b", "#bdcf32", "#87bc45"]

# checking plot of resting ecg
plt.figure(figsize = (12, 5))
plt.subplot(1, 2, 1)
ecg_plot = sns.countplot(x = heart_disease.RestingECG, order = heart_disease.RestingECG.value_counts().index, palette = ecg_colors)
ecg_plot.set_title('Distribusi dari Tekanan Darah')
ecg_plot.set_xticklabels(ecg_label, fontsize = 15)
for p in ecg_plot.patches:
   ecg_plot.annotate('{:.0f}'.format(p.get_height()), (p.get_x()+0.25, p.get_height()+0.01))

plt.subplot(1, 2, 2)
ecg_pie = heart_disease['RestingECG'].value_counts()
ecg_pie = ecg_pie.plot.pie(explode = [0.1, 0.1, 0.1], labels = ecg_label, colors = ecg_colors, autopct = '%1.1f%%', shadow = True)
ecg_pie.set_title(label = 'Persentase Tekanan Darah')
plt.legend()
plt.axis('off')

"""Pada variabel `ExerciseAngina` yang disajikan oleh dua _plot_, dapat diketahui bahwa lebih banyak yang melakukan latihan angina, yakni sebesar 65.0%"""

angina_label = ['Tidak', 'Ya']
angina_color = ["#fd7f6f", "#7eb0d5"]

# checking plot of exercise angina
plt.figure(figsize = (12, 5))
plt.subplot(1, 2, 1)
angina_plot = sns.countplot(x = heart_disease.ExerciseAngina, order = heart_disease.ExerciseAngina.value_counts().index, palette = angina_color)
angina_plot.set_title('Distribusi dari Angina')
angina_plot.set_xticklabels(angina_label, fontsize = 15)
for p in angina_plot.patches:
   angina_plot.annotate('{:.0f}'.format(p.get_height()), (p.get_x()+0.25, p.get_height()+0.01))

plt.subplot(1, 2, 2)
angina_pie = heart_disease['ExerciseAngina'].value_counts()
angina_pie = angina_pie.plot.pie(explode = [0.1, 0.1], labels = angina_label, colors = angina_color, autopct = '%1.1f%%', shadow = True)
angina_pie.set_title(label = 'Angina')
plt.legend()
plt.axis('off')

"""Pada variabel `ST_Slope` yang disajikan oleh dua _plot_, dapat diketahui bahwa `Flat` lebih banyak yang memiliki kemiringan pada puncak segmen ST, yakni sebesar 51.6%"""

slope_label = ['Up', 'Flat', 'Down']
slope_color = ["#beb9db", "#fdcce5", "#8bd3c7"]

# checking plot of ST Slope
plt.figure(figsize = (12, 5))
plt.subplot(1, 2, 1)
slope_plot = sns.countplot(x = heart_disease.ST_Slope, order = heart_disease.ST_Slope.value_counts().index, palette = slope_color)
slope_plot.set_title('Distribusi dari ST Slope')
slope_plot.set_xticklabels(slope_label, fontsize = 15)
for p in slope_plot.patches:
   slope_plot.annotate('{:.0f}'.format(p.get_height()), (p.get_x()+0.25, p.get_height()+0.01))

plt.subplot(1, 2, 2)
slope_pie = heart_disease['ST_Slope'].value_counts()
slope_pie = slope_pie.plot.pie(explode = [0.1, 0.1, 0.1], labels = slope_label, colors = slope_color, autopct = '%1.1f%%', shadow = True)
slope_pie.set_title(label = 'ST Slope')
plt.legend()
plt.axis('off')

"""#### Analisis terhadap fitur numerical

melihat histogram masing-masing fitur _numerical_ yaitu `Age`, `RestingBP`, `Cholesterol`, `MaxHR`, dan `Oldpeak`
"""

heart_disease[['Age', 'RestingBP', 'Cholesterol', 'MaxHR', 'Oldpeak']].hist(bins=50, figsize=(20,15))
plt.show()

"""### Multivariate Analysis

#### Analisis terhadap categocial

Mengecek rerata `heart disease` terhadap masing-masing fitur untuk mengetahui pengaruh fitur terhadap `heart disease`
"""

for i in range(len(categorical_feature)-1):
    plt.figure(figsize = (12, 7))
    catp = sns.catplot(x = 'HeartDisease', data = heart_disease, hue = categorical_feature[i], kind = 'count', palette = 'pastel', edgecolor = '.8')
    ax = catp.facet_axis(0, 0)
    
    for c in ax.containers:
        labels = [f'{(v.get_height()):.0f}' for v in c]
        ax.bar_label(c, labels=labels, label_type='edge')


    plt.title('Rerata Heart Disease terhadap - {}'.format(categorical_feature[i]))
    plt.show()

categorical_feature

"""Dengan mengamati rata-rata harga relatif terhadap fitur _categorical_ di atas, didapatkan _insight_ sebagai berikut:

Heart Disease [0] menunjukkan bahwa pasien Normal
Heart Disease [1] menunjukkan bahwa pasien memiliki penyakit jantung
- Pada fitur `sex`, rerata penyakit jantung atau _heart disease_ menyerang seseorang berjenis kelamin pria, dibanding wanita. Hal ini dapat dilihat pada bar chart [1] yang melambangkan pasien memiliki penyakit jantung. Pada pasien normal (tidak memiliki penyakit jantung, dilambangkan dengan [0]), rerata didominasi dengan pria. Hal yang sama juga terjadi pada pasien dengan penyakit jantung (dilambangkan dengan [1]), yang rerata didominasi dengan pria.
- Pada fitur `ChestPainType`, rerata pasien yang memiliki penyakit jantung (dilambangkan dengan [1]) memiliki sakit dada dengan tipe _Asymptomatic_ [ASY] sebannyak 392 kasus.
- Pada fitur `FastingBS`, rerata pasien yang memiliki penyakit jantung (dilambangkan dengan [1]) memiliki gula darah di bawah 120 mg/dl. Sedangkan pasien yang memiliki gula darah > 120 mg/dl cenderung tidak memiliki penyakit jantung.
- Pada fitur `RestingECG`, rerata pasien yang memiliki penyakit jantung (dilambangkan dengan [1]) memiliki tekanan darah yang normal.
- Pada fitur `ExerciseAngina`, rerata pasien yang memiliki penyakit jantung (dilambangkan dengan [1]) memiliki angin.
- Pada fitur `ST_Slope`, rerata pasien yang memiliki penyakit jantung (dilambangkan dengan [1]) memiliki segmen ST yang bertipe flat.

#### Analisis terhadap fitur numerical

Melakukan observasi korelasi antara fitur numerical dengan fitur target menggunakan fungsu `corr()`
"""

heart_disease.select_dtypes(['int64', 'float64'])

sns.pairplot(heart_disease.select_dtypes(['int64', 'float64']), diag_kind = 'kde')

"""Dibuat heatmap untuk melihat lebih jelas fitur numerical yang memiliki korelasi dengan _heart disease_"""

plt.figure(figsize=(10, 8))
correlation_matrix = heart_disease.corr().round(2)
 
sns.heatmap(data = correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5, )
plt.title("Correlation Matrix untuk Fitur Numerical ", size=20)

"""## Data Preparation
Pada bagian ini Anda menerapkan dan menyebutkan teknik data preparation yang dilakukan. Teknik yang digunakan pada notebook dan laporan harus berurutan.

_Data preparation_ yang digunakan di antaranya:

1. Seleksi data: menyeleksi data apakah data tersebut ada yang kosong atau tidak, jika ada data kosong maka akan dihapus.

`isnull().sum()` merupakan _command_ yang digunakan untuk mengecek apakah terdapat data yang kosong atau _missing data_ dan menjumlahkan banyak datanya. Namun, tidak terdapat data kosong atau _missing data_.
"""

# checking null dataset and sum it, if any
heart_disease.isna().sum()

"""2. Menangani Outlier: melakukan pengechekan apakah data _heart disease_ memiliki data outlier. Apabila terdapat data outlier, maka akan dihapus.

Untuk mengetahui data outlier yang dimiliki oleh dataset _heart disease_, maka digunakanlah `boxplot` yang memperlihatkan langsung keseluruhan dataset _heart disease_. Dapat dilihat bahwa terdapat beberapa outlier, khususnya pada fitur `Cholesterol` yang memiliki outlier paling banyak.
"""

plt.figure(figsize=(15,20))

plt.subplot(5,2,1)
sns.distplot(heart_disease['Age'],color='DeepPink')
plt.subplot(5,2,2)
sns.boxplot(heart_disease['Age'],color='DeepPink')

plt.subplot(5,2,3)
sns.distplot(heart_disease['RestingBP'],color='DarkSlateGray')
plt.subplot(5,2,4)
sns.boxplot(heart_disease['RestingBP'],color='DarkSlateGray')

plt.subplot(5,2,5)
sns.distplot(heart_disease['Cholesterol'],color='Green')
plt.subplot(5,2,6)
sns.boxplot(heart_disease['Cholesterol'],color='Green')

plt.subplot(5,2,7)
sns.distplot(heart_disease['MaxHR'],color='Red')
plt.subplot(5,2,8)
sns.boxplot(heart_disease['MaxHR'],color='Red')

plt.subplot(5,2,9)
sns.distplot(heart_disease['Oldpeak'],color='Brown')
plt.subplot(5,2,10)
sns.boxplot(heart_disease['Oldpeak'],color='Brown')

plt.tight_layout()
plt.show()

# Handling Outliers
plt.figure(figsize = (12, 7))
sns.boxplot(data = heart_disease[['Age', 'RestingBP', 'Cholesterol', 'MaxHR', 'Oldpeak']])

"""IQR bertujuan untuk mengapuskan outlier yang ada. Hasil akhir data dari outlier yang telah dihapuskan dapat dilihat dengan `shape`."""

hd_outlier = heart_disease[['Age', 'RestingBP', 'Cholesterol', 'MaxHR', 'Oldpeak']]
# drop outliers
Q1 = hd_outlier.quantile(0.25)
Q3 = hd_outlier.quantile(0.75)

IQR = Q3 - Q1

outlier = hd_outlier[~((hd_outlier<(Q1-1.5*IQR))|(hd_outlier>(Q3+1.5*IQR))).any(axis=1)]

"""Setelah menangani outlier dengan IQR, maka didapatkan `shape` sebagai berikut:"""

outlier.shape

"""Karena ditemukannya `cholesterol` yang memiliki nilai 0, maka nilai tersebut akan diganti dengan median dari `cholesterol`"""

heart_disease.loc[ heart_disease['Cholesterol'] == 0, 'Cholesterol'] == np.nan
heart_disease.head()

heart_disease['Cholesterol'] = heart_disease['Cholesterol'].fillna(heart_disease['Cholesterol'].median())
heart_disease['Cholesterol']

"""Blood Pressure pada fitur `RestingBP` memiliki 5 range, yakni Normal, Pre Hyper Tension, High Blood Pressude Stage 1, High Blood Pressuse Stage 2, dan Hyper Tensive. Maka, dibuatlah range-range baru terhadap Blood Pressure."""

heart_disease = heart_disease.drop(heart_disease[(heart_disease['RestingBP'] == 0)].index) 
normal_RestingBP = heart_disease[heart_disease['RestingBP'] <= 120 ]
PreHyper_RestingBP = heart_disease[(heart_disease['RestingBP'] > 120) & (heart_disease['RestingBP']<= 139) ]
High1_RestingBP = heart_disease[(heart_disease['RestingBP'] >= 140) & (heart_disease['RestingBP']<= 159) ]
High2_RestingBP = heart_disease[(heart_disease['RestingBP'] >= 160) & (heart_disease['RestingBP']<= 180) ]
HyperTensive_RestingBP = heart_disease[heart_disease['RestingBP'] >= 180]

bp_label = ['Normal', 'PreHyper', 'High1', 'High2', 'HyperTensive']
bp_size = [292, 298, 234, 85, 20]
bp_color = ["#fd7f6f", "#7eb0d5", "#b2e061", "#bd7ebe", "#ffb55a"]

# checking plot of ST bp
plt.figure(figsize = (12, 5))
plt.pie(x = bp_size, explode = [0.1, 0.1, 0.1, 0.1, 0.1], labels = bp_label, colors = bp_color, autopct = '%1.1f%%', shadow = True)
plt.title('Blood Pressure', fontsize = 15)
plt.legend()
plt.axis('off')

"""3. Melakukan Label Encoder: Melakukan proses encoding terhadap `categorical_feature`

LabelEncoder() dilakukan terhadap fitur-fitur categorical
"""

from sklearn.preprocessing import LabelEncoder

ChestPainType_label = LabelEncoder()
RestingECG_label = LabelEncoder()
ExerciseAngine_label = LabelEncoder()
ST_Slope_label = LabelEncoder()
Sex_label = LabelEncoder()

heart_disease['ChestPainType'] = ChestPainType_label.fit_transform(heart_disease['ChestPainType'])
heart_disease['RestingECG'] = RestingECG_label.fit_transform(heart_disease['RestingECG'])
heart_disease['ExerciseAngina'] = ExerciseAngine_label.fit_transform(heart_disease['ExerciseAngina'])
heart_disease['ST_Slope'] = ST_Slope_label.fit_transform(heart_disease['ST_Slope'])
heart_disease['Sex'] = Sex_label.fit_transform(heart_disease['Sex'])

heart_disease.info()

#Correlation between all features 
fig , ax = plt.subplots(figsize=(13,6))   
sns.heatmap(heart_disease.corr(), cmap="coolwarm", linecolor='white' , annot=True , linewidths=1 , ax=ax )

"""4. Membagi Data menjadi Training dan Testing"""

X = heart_disease.drop('HeartDisease', axis = 1)
Y = heart_disease.HeartDisease

from sklearn.model_selection import train_test_split

Xtrain, Xtest, ytrain, ytest = train_test_split(X, Y, test_size = 0.2, random_state = 21)

print('Shape dari Xtrain', Xtrain.shape)
print('Shape dari Xest', Xtest.shape)

"""5. Standarisasi"""

from sklearn.preprocessing import StandardScaler
 
std_scaler = StandardScaler()
std_scaler.fit(X)

Xtrain = std_scaler.transform(Xtrain)
Xtest = std_scaler.transform(Xtest)

Xtrain = pd.DataFrame(Xtrain, columns=X.columns)
Xtest = pd.DataFrame(Xtest, columns=X.columns)

model = pd.DataFrame( index = ['train_mse', 'test_mse'],
                      columns = ['KNN', 'AdaBoost', 'RandomForest'])

"""## Modeling

Proses modeling yang dilakukan menggunakan 3 algoritma dan mencari performa yang paling baik di antara ketiganya.
"""

from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import mean_squared_error

knn = KNeighborsClassifier(n_neighbors = 10)
knn.fit(Xtrain, ytrain)
ypred = knn.predict(Xtrain)
ytrue = ytrain

model.loc['train_mse', 'KNN'] = mean_squared_error(ypred, ytrue)

from sklearn.ensemble import RandomForestClassifier

rf = RandomForestClassifier(max_features = 7, max_depth = 3)
rf.fit(Xtrain, ytrain)
ypred = rf.predict(Xtrain)
ytrue = ytrain

model.loc['train_mse', 'RandomForest'] = mean_squared_error(ypred, ytrue)

from sklearn.ensemble import AdaBoostClassifier

ada = AdaBoostClassifier(n_estimators = 3, learning_rate = 0.2)
ada.fit(Xtrain, ytrain)
ypred = ada.predict(Xtrain)
ytrue = ytrain

model.loc['train_mse', 'AdaBoost'] = mean_squared_error(ypred, ytrue)

"""## Evaluasi Model

Evaluasi metrik yang digunakan untuk mengukur kinerja model adalah metrik mse (Mean Squared Error). Pemilihan matrik ini disebabkan karena kasus atau domain proyek yang dipilih adalah klasifikasi. Matrik MSE, pada dasarnya akan mengukur kuadrat rerata error dari prediksi yang dilakukan. MSE juga akan menghitung selisih kuadrat antara prediksi dan target, yang kemudian melakukan perhitungan rata-rata terhadap nilai-nilai tersebut.

Semakin tinggi nilai yang diperoleh MSE, semakin buruk juga modelnya. Nilai MSE tidak pernah negatif, tetapi akan menjadi NOL untuk model yang sempurna.
"""

# Buat variabel mse yang isinya adalah dataframe nilai mse data train dan test pada masing-masing algoritma
mse = pd.DataFrame(columns=['train', 'test'], index=['KNN', 'AdaBoost', 'RandomForest'])
 
# Buat dictionary untuk setiap algoritma yang digunakan
model_dict = {'KNN': knn, 'AdaBoost': ada, 'RandomForest': rf}
 
# Hitung Mean Squared Error masing-masing algoritma pada data train dan test
for name, model in model_dict.items():
    mse.loc[name, 'train'] = mean_squared_error(y_true=ytrain, y_pred=model.predict(Xtrain))/1e3 
    mse.loc[name, 'test'] = mean_squared_error(y_true=ytest, y_pred=model.predict(Xtest))/1e3
 
# Panggil mse
mse

fig, ax = plt.subplots()
mse.sort_values(by='test', ascending=False).plot(kind='barh', ax=ax, zorder=3)
ax.grid(zorder=0)

"""Dari _plot_ yang disajikan di atas, dapat diketahui bahwa model KNN memberikan nilai error yang paling kecil. Sehingga, model KNN lah yang dipilih sebagai model terbaik untuk melakukan klasifikasi penyakit jantung."""

prediksi = Xtest.iloc[:5].copy()
pred_dict = {'y_true':ytest[:5]}
for name, model in model_dict.items():
    pred_dict['prediksi_'+name] = model.predict(prediksi).round(1)
 
pd.DataFrame(pred_dict)

"""Hasil prediksi yang diberikan oleh model KNN adalah benar, dibandingkan dengan prediksi AdaBoost dan RandomForest."""

